package main

import (
	"fmt"
	"os"
	"sort"
	"strings"

	"github.com/containrrr/shoutrrr/pkg/format"
	cli "github.com/containrrr/shoutrrr/shoutrrr/cmd"
	"github.com/spf13/cobra"
	"gopkg.in/yaml.v2"
)

var cmd = &cobra.Command{
	Use:  "shoutrrr-gen",
	RunE: run,
}

var (
	lang   string
	source string
)

func init() {
	lang = *cmd.Flags().StringP("lang", "l", "", "Output language")
	source = *cmd.Flags().StringP("source", "s", "", "Source file")
}

func main() {
	if err := cmd.Execute(); err != nil {
		os.Exit(cli.ExUsage)
	}
}

func run(c *cobra.Command, args []string) error {
	cwd, err := os.Getwd()
	if err != nil {
		return err
	}
	fmt.Printf("CWD: %v\n", cwd)
	specFile := args[0]
	specBytes, err := os.ReadFile(specFile)
	if err != nil {
		return err
	}

	spec := format.ConfigSpec{}
	if err := yaml.Unmarshal(specBytes, &spec); err != nil {
		return err
	}

	fmt.Printf("Source: %q\n", source)
	fmt.Printf("Lang: %q\n", lang)

	gofile, _ := os.LookupEnv("GOFILE")
	gopackage, _ := os.LookupEnv("GOPACKAGE")

	fmt.Printf("Config file: %q\n", gofile)
	fmt.Printf("Service: %q\n", gopackage)

	genfile := strings.Replace(gofile, "config.go", "config.gen.go", 1)
	src, err := os.Create(genfile)
	if err != nil {
		return err
	}
	defer src.Close()

	// wc := func(v ...interface{}) {
	// 	fmt.Fprint(src, v...)
	// }
	wl := func(v ...interface{}) {
		fmt.Fprintln(src, v...)
	}
	wf := func(format string, v ...interface{}) {
		fmt.Fprintf(src, format+"\n", v...)
	}

	wf("// Code generated by \"shoutrrr-gen %s\"; DO NOT EDIT.", strings.Join(os.Args[1:], " "))

	wl(`package`, gopackage)
	wl()
	wl(`import (`)
	wl(`	"fmt"`)
	wl(`	"net/url"`)
	// wl(`	"strconv"`)
	wl(`	"strings"`)
	wl()
	wl(`	"github.com/containrrr/shoutrrr/pkg/types"`)
	wl(`	"github.com/containrrr/shoutrrr/pkg/format"`)
	wl(`)`)
	wl()

	propNames := mapKeys(spec.Props)
	sort.Strings(propNames)

	urlProps := map[format.URLPart]string{}
	keyProps := map[string]string{}
	enumProps := map[string][]string{}
	wl(`type Config struct {`)
	for _, p := range propNames {
		ps := spec.Props[p]
		spec.Props[p].Name = p
		wf(`	%v %v`, p, goType(ps))
		for _, up := range ps.URLParts {
			urlProps[up] = p
		}
		for _, key := range ps.Keys {
			keyProps[key] = p
		}
		if len(ps.Values) > 0 {
			enumProps[p] = ps.Values
		}
	}
	wl(`}`)

	keys := make([]string, 0, len(keyProps))
	for key := range keyProps {
		keys = append(keys, key)
	}
	sort.Strings(keys)

	wl()
	wl(`type configProp int`)
	wl(`const (`)
	for i, name := range propNames {
		wf(`	prop%v	configProp = %v`, name, i)
	}
	wf(`	propCount = %d`, len(propNames))
	wl(`)`)

	wl(`var propNames = []string{`)
	for _, name := range propNames {
		wf(`	%q,`, name)
	}
	wl(`}`)

	wl()
	//wl(`type PropName string`)
	wl(`var propKeys = []string{`)
	for _, key := range keys {
		wf(`	%q,`, key)
	}
	wl(`}`)

	wl()

	wl(`var defaultValues = []string{`)
	for _, name := range propNames {
		wf(`	%q,`, spec.Props[name].DefaultValue)
	}
	wl(`}`)

	wl()

	wl(`// GetURL returns a URL representation of it's current field values`)
	wl(`func (config *Config) GetURL() *url.URL {`)

	wl(`	return &url.URL{`)
	wl(getUserInfoSetter(urlProps))
	if p, found := urlProps[format.URLHost]; found {
		wf(`		Host: config.%v,`, p)
	}
	wl(`	}`)
	wl(`}`)
	wl()
	wl(`// SetURL updates a ServiceConfig from a URL representation of it's field values`)
	wl(`func (config *Config) SetURL(url *url.URL) error {`)
	if p, found := urlProps[format.URLHost]; found {
		wf(`	config.%v = url.Host`, p)
	}
	if p, found := urlProps[format.URLUser]; found {
		wf(`	config.%v = url.User.Username()`, p)
	}
	if p, found := urlProps[format.URLPassword]; found {
		wl(`	if pwd, found := url.User.Password(); found {`)
		wf(`		config.%v = pwd`, p)
		wl(`	}`)
	}
	wl()
	for _, key := range keys {
		p := keyProps[key]
		prop := spec.Props[p]
		wf(`	if qv := url.Query()["%v"]; len(qv) == 1 {`, key)
		switch spec.Props[p].Type {
		case format.TextPropType:
			wf(`		config.%v = qv[0]`, p)
		case format.TogglePropType:
			wf(`		if v, ok := format.ParseBool(qv[0], false); ok {`)
			wf(`			config.%v = v`, p)
			wl(`		}`)
		case format.NumberPropType:
			wf(`		if v, err := strconv.ParseInt(qv[0], %d, 64); err == nil {`, prop.Base)
			wf(`			config.%v = v`, p)
			wl(`		} else {`)
			wf(`			return fmt.Errorf("Error parsing value for %v: %%v", err)`, p)
			wl(`		}`)
		case format.OptionPropType:
			wf(`		if v := %vFormatter.Parse(qv[0]); v != format.EnumInvalid {`, p)
			wf(`			config.%v = format.Option(v)`, p)
			wl(`		} else {`)
			wf(`			return fmt.Errorf("Error parsing value for %v: %%q is not a valid option", qv[0])`, p)
			wl(`		}`)
		case format.ListPropType:
			wf(`		config.%v = strings.Split(qv[0], ",")`, p)
		default:
			wf(`		// TODO: Implement prop type setter for %q`, prop.Type)
		}
		wl(`	}`)
	}
	wl()
	wl(`	return nil`)
	wl(`}`)
	// for _, e := range os.Environ() {
	// 	fmt.Printf("ENV: %v\n", e)
	// }
	wl()
	wl(`func (config *Config) Enums() map[string]types.EnumFormatter {`)
	wl(`	return map[string]types.EnumFormatter{`)
	for p, _ := range enumProps {
		wf(`		%q: %sFormatter,`, p, p)
	}
	wl(`	}`)
	wl(`}`)
	wl()
	wl(`var (`)
	for p, vals := range enumProps {
		wf(`	%sFormatter = format.CreateEnumFormatter([]string{`, p)
		for _, val := range vals {
			wf(`		%q,`, val)
		}
		wl(`	})`)
	}
	wl(`)`)

	wl(`// Update updates the Config from a map of it's properties`)
	wl(`func (config *Config) Update(updates map[string]string) error {`)
	wl(`	var last_err error`)
	wl(`	for key, value := range updates {`)
	wl(`		switch key {`)
	for _, name := range propNames {
		p := spec.Props[name]
		wf(`		case %q:`, name)
		wf(`			if val, err := format.%v; err != nil {`, p.Type.ParserCall(p, "value"))
		wf(`				last_err = err`)
		wf(`			} else {`)
		wf(`				config.%v = val`, name)
		wf(`			}`)
	}
	wl(`		default:`)
	wl(`			last_err = fmt.Errorf("invalid key")`)
	wl(`		}`)
	wl(`		if last_err != nil {`)
	wl(`			return fmt.Errorf("failed to set value for %q: %v", key, last_err)`)
	wl(`		}`)
	wl(`	}`)
	wl(`	return nil`)
	wl(`}`)
	wl()

	wl(`// Init sets all the Config properties to their default values`)
	wl(`func (config *Config) Init() {`)
	wl(`	updates := make(map[string]string, len(propCount))`)
	wl(`	for i, name := range propNames {`)
	wl(`		updates[name] = defaultValues[i]`)
	wl(`	}`)
	wl(`	config.Update(updates)`)
	wl(`}`)
	wl()

	return nil
}

func goType(ps *format.ConfigSpecProp) string {
	switch ps.Type {
	case format.TextPropType:
		return "string"
	case format.TogglePropType:
		return "bool"
	case format.NumberPropType:
		return "int64"
	case format.OptionPropType:
		return "format.Option"
	case format.ListPropType:
		return "[]string"
	default:
		return "interface{}"
	}
}

func getUserInfoSetter(urlProps map[format.URLPart]string) string {
	var prop string
	var user_found bool
	var pass_found bool
	user := `""`
	if prop, user_found = urlProps[format.URLUser]; user_found {
		user = "config." + prop
	}
	pass := `""`
	if prop, pass_found = urlProps[format.URLPassword]; pass_found {
		pass = "config." + prop
	}

	if pass_found {
		return fmt.Sprintf(`		User: url.UserPassword{username: %v, password: %v},`, user, pass)
	} else if user_found {
		return fmt.Sprintf(`		User: url.User(%v),`, user)
	}

	return "		// Userinfo fields are not used for configuraion"
}

func mapKeys[V any](m map[string]V) []string {
	keys := make([]string, 0, len(m))
	for name := range m {
		keys = append(keys, name)
	}
	return keys
}
