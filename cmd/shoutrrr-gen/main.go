package main

import (
	"fmt"
	"os"
	"sort"
	"strings"

	"github.com/containrrr/shoutrrr/pkg/cli"
	"github.com/containrrr/shoutrrr/pkg/format"
	"github.com/spf13/cobra"
	"gopkg.in/yaml.v2"
)

var cmd = &cobra.Command{
	Use:  "shoutrrr-gen",
	RunE: run,
}

var (
	lang   string
	source string
)

func init() {
	lang = *cmd.Flags().StringP("lang", "l", "", "Output language")
	source = *cmd.Flags().StringP("source", "s", "", "Source file")
}

func main() {
	if err := cmd.Execute(); err != nil {
		os.Exit(cli.ExUsage)
	}
}

func run(c *cobra.Command, args []string) error {
	cwd, err := os.Getwd()
	if err != nil {
		return err
	}
	fmt.Printf("CWD: %v\n", cwd)
	specFile := args[0]
	specBytes, err := os.ReadFile(specFile)
	if err != nil {
		return err
	}

	spec := format.ConfigSpec{}
	if err := yaml.Unmarshal(specBytes, &spec); err != nil {
		return err
	}

	fmt.Printf("Source: %q\n", source)
	fmt.Printf("Lang: %q\n", lang)

	gofile, _ := os.LookupEnv("GOFILE")
	gopackage, _ := os.LookupEnv("GOPACKAGE")

	fmt.Printf("Config file: %q\n", gofile)
	fmt.Printf("Service: %q\n", gopackage)

	genfile := strings.Replace(gofile, "config.go", "config.gen.go", 1)
	src, err := os.Create(genfile)
	if err != nil {
		return err
	}
	defer src.Close()

	wl := func(v ...interface{}) {
		fmt.Fprintln(src, v...)
	}
	wf := func(format string, v ...interface{}) {
		fmt.Fprintf(src, format+"\n", v...)
	}

	wf("// Code generated by \"shoutrrr-gen %s\"; DO NOT EDIT.", strings.Join(os.Args[1:], " "))

	wl(`package`, gopackage)
	wl()
	wl(`import (`)
	wl(`	"fmt"`)
	wl(`	"net/url"`)
	wl(`	"strings"`)
	wl()
	wl(`	"github.com/containrrr/shoutrrr/pkg/types"`)
	wl(`	"github.com/containrrr/shoutrrr/pkg/format"`)
	wl(`)`)
	wl()

	propNames, maxPropNameLen := mapKeys(spec.Props)
	sort.Strings(propNames)
	propNamePad := strings.Repeat(" ", maxPropNameLen)

	urlProps := map[format.URLPart]string{}
	keyProps := map[string]string{}
	enumProps := map[string][]string{}
	wl(`type Config struct {`)
	for _, p := range propNames {
		ps := spec.Props[p]
		spec.Props[p].Name = p
		tags := legacyTags(spec.Props[p])
		wf(`	%v%s %v %v`, p, propNamePad[:len(propNamePad)-len(p)], goType(ps), tags)
		for _, up := range ps.URLParts {
			urlProps[up] = p
		}
		for _, key := range ps.Keys {
			keyProps[key] = p
		}
		if len(ps.Values) > 0 {
			enumProps[p] = ps.Values
		}
	}
	wl(`}`)

	keys := make([]string, 0, len(keyProps))
	for key := range keyProps {
		keys = append(keys, key)
	}
	sort.Strings(keys)

	wl()
	wl(`type configProp int`)
	wl(`const (`)
	for i, name := range propNames {
		wf(`	prop%v%s configProp = %v`, name, propNamePad[:len(propNamePad)-len(name)], i)
	}
	wf(`	propCount = %d`, len(propNames))
	wl(`)`)

	wl(`var propNames = []string{`)
	for _, name := range propNames {
		wf(`	%q,`, name)
	}
	wl(`}`)

	wl()
	wl(`// Note that propKeys may not align with propNames, as a property can have no or multiple keys`)
	wl(`var propKeys = []string{`)
	for _, key := range keys {
		wf(`	%q,`, key)
	}
	wl(`}`)

	wl()

	wl(`var keyProp = []configProp{`)
	for _, key := range keys {
		wf(`	prop%v,`, keyProps[key])
	}
	wl(`}`)

	wl()

	wl(`var defaultValues = []string{`)
	for _, name := range propNames {
		wf(`	%q,`, spec.Props[name].DefaultValue)
	}
	wl(`}`)

	wl()

	wl(`var primaryKeys = []int{`)
	for _, name := range propNames {
		propKeys := spec.Props[name].Keys
		keyIndex := -1
		if len(propKeys) > 0 {
			for i, key := range keys {
				if key == propKeys[0] {
					keyIndex = i
					break
				}
			}
		}
		wf(`	%v,`, keyIndex)
	}
	wl(`}`)

	wl()

	// ### GetURL ###

	wl(`// GetURL returns a URL representation of it's current field values`)
	wl(`func (config *Config) GetURL() *url.URL {`)

	wl(`	return &url.URL{`)
	wl(getUserInfoSetter(urlProps))
	if p, found := urlProps[format.URLHost]; found {
		wf(`		Host: config.%v,`, p)
	}
	if p, found := urlProps[format.URLPath1]; found {
		wf(`		Path: config.%v,`, p)
	} else {
		wl(`		Path: "/",`)
	}
	wf(`		RawQuery: config.QueryValues().Encode(),`)
	wf(`		Scheme: Scheme,`)
	wl(`	}`)
	wl(`}`)
	wl()

	// ### SetURL ###

	wl(`// SetURL updates a ServiceConfig from a URL representation of it's field values`)
	wl(`func (config *Config) SetURL(url *url.URL) error {`)
	wl(`	updates := make(map[string]string, propCount)`)
	if p, found := urlProps[format.URLHost]; found {
		wf(`	updates[%q] = url.Host`, p)
	}
	if p, found := urlProps[format.URLUser]; found {
		wf(`	updates[%q] = url.User.Username()`, p)
	}
	if p, found := urlProps[format.URLPassword]; found {
		wl(`	if pwd, found := url.User.Password(); found {`)
		wf(`		updates[%q] = pwd`, p)
		wl(`	}`)
	}
	if p, found := urlProps[format.URLPath1]; found {
		wf(`	updates[%q] = url.Path`, p)
	}
	wl()
	wl(`	for key, value := range url.Query() {`)
	wl(`		propName, err := propNameFromKey(key)`)
	wl(`		if err == nil {`)
	wl(`			updates[propName] = value[0]`)
	wl(`		} else if key != "title" {`)
	wl(`			return fmt.Errorf("invalid key %q", key)`)
	wl(`		}`)
	wl(`	}`)
	// for _, key := range keys {
	// 	p := keyProps[key]
	// 	wf(`	if qv := url.Query()["%v"]; len(qv) == 1 {`, key)
	// 	wf(`        updates["%v"] = qv[0]`, p)
	// 	wl(`	}`)
	// }
	wl()
	wl(`	err := config.Update(updates); if err != nil {`)
	wl(`		return err`)
	wl(`	}`)
	wl()
	for _, pn := range propNames {
		prop := spec.Props[pn]
		if !prop.Required {
			continue
		}
		wf(`	if %v {`, prop.Type.EmptyCall(prop, "config."+pn))
		wf(`		return fmt.Errorf("%v missing from config URL")`, pn)
		wl(`	}`)
		wl()
	}

	wl(`	return nil`)
	wl(`}`)
	wl()

	// ### ENUMS ###

	wl(`func (config *Config) Enums() map[string]types.EnumFormatter {`)
	wl(`	return map[string]types.EnumFormatter{`)
	for p := range enumProps {
		wf(`		%q: %sOptions.Formatter,`, p, p)
	}
	wl(`	}`)
	wl(`}`)
	wl()
	// wl(`var (`)
	for p, vals := range enumProps {
		wf(`// %v Option`, p)

		typeName := optionTypeName(p)
		structName := typeName + "Vals"
		wf(`type %v int`, typeName)
		wl()
		wf(`type %v struct {`, structName)
		for _, val := range vals {
			wf(`	%s	%s`, val, typeName)
		}
		wl(`	Formatter types.EnumFormatter`)
		wl(`}`)
		wl()
		wf(`var %vOptions = &%v {`, p, structName)
		for i, val := range vals {
			wf(`	%s:	%v,`, val, i)
		}
		wl(`	Formatter: format.CreateEnumFormatter([]string{`)
		for _, val := range vals {
			wf(`		%q,`, val)
		}
		wl(`	}),`)
		wl(`}`)
		wl()
		wf(`func (ov *%v) Parse(v string) (%v, error) {`, structName, typeName)
		wf(`	if val := ov.Formatter.Parse(v); val != format.EnumInvalid {`)
		wf(`		return %v(val), nil`, typeName)
		wf(`	} else {`)
		wf(`		return %v(val), fmt.Errorf("invalid option %%q for %v", v)`, typeName, p)
		wf(`	}`)
		wf(`}`)
		wl()
	}

	// ### UPDATE ###

	wl(`// Update updates the Config from a map of it's properties`)
	wl(`func (config *Config) Update(updates map[string]string) error {`)
	wl(`	var last_err error`)
	wl(`	for key, value := range updates {`)
	wl(`		switch key {`)
	for _, name := range propNames {
		p := spec.Props[name]
		wf(`		case %q:`, name)
		wf(`			if val, err := %v; err != nil {`, p.Type.ParserCall(p, "value"))
		wf(`				last_err = err`)
		wf(`			} else {`)
		wf(`				config.%v = val`, name)
		wf(`			}`)
	}
	wl(`		default:`)
	wl(`			last_err = fmt.Errorf("invalid key")`)
	wl(`		}`)
	wl(`		if last_err != nil {`)
	wl(`			return fmt.Errorf("failed to set value for %q: %v", key, last_err)`)
	wl(`		}`)
	wl(`	}`)
	wl(`	return nil`)
	wl(`}`)
	wl()

	wl(`// Update updates the Config from a map of it's properties`)
	wl(`func (config *Config) propValue(prop configProp) string {`)
	wl(`	switch prop {`)
	for _, name := range propNames {
		p := spec.Props[name]
		wf(`	case prop%v:`, name)
		wf(`		return %v`, p.Type.FormatCall(p, "config."+name))
	}
	wl(`	default:`)
	wl(`		return ""`)
	wl(`	}`)
	wl(`}`)
	wl()

	wl(`func propNameFromKey(key string) (string, error) {`)
	wl(`	key = strings.ToLower(key)`)
	wl(`	for i, pk := range propKeys {`)
	wl(`		if key == pk {`)
	wl(`			return propNames[keyProp[i]], nil`)
	wl(`		}`)
	wl(`	}`)
	wl(`	return "", fmt.Errorf("invalid key %q", key)`)
	wl(`}`)
	wl()

	wl(`// UpdateFromParams`)
	wl(`func (config *Config) UpdateFromParams(params *types.Params) error {`)
	wl(`	if params == nil {`)
	wl(`		return nil`)
	wl(`	}`)
	wl(`	updates := make(map[string]string, len(*params))`)
	wl(`	for key, value := range *params {`)
	wl(`		propName, err := propNameFromKey(key)`)
	wl(`		if err == nil {`)
	wl(`			updates[propName] = value`)
	wl(`		} else if key != "title" {`)
	wl(`			return fmt.Errorf("invalid key %q", key)`)
	wl(`		}`)
	wl(`	}`)
	wl(`	return config.Update(updates)`)
	wl(`}`)
	wl()

	wl(`// UpdateFromParams`)
	wl(`func (config *Config) UpdateFromQuery(values url.Values) error {`)
	wl(`	updates := make(map[string]string, len(values))`)
	wl(`	for key, value := range values {`)
	wl(`		propName, err := propNameFromKey(key)`)
	wl(`		if err == nil {`)
	wl(`			updates[propName] = value[0]`)
	wl(`		} else if key != "title" {`)
	wl(`			return fmt.Errorf("invalid key %q", key)`)
	wl(`		}`)
	wl(`	}`)
	wl(`	return config.Update(updates)`)
	wl(`}`)
	wl()

	wl(`// Init sets all the Config properties to their default values`)
	wl(`func (config *Config) Init() {`)
	wl(`	updates := make(map[string]string, propCount)`)
	wl(`	for i, name := range propNames {`)
	wl(`		updates[name] = defaultValues[i]`)
	wl(`	}`)
	wl(`	config.Update(updates)`)
	wl(`}`)
	wl()

	wl(`// Init sets all the Config properties to their default values`)
	wl(`func (config *Config) QueryValues() url.Values {`)
	wl(`	values := make(url.Values, propCount)`)
	wl(`	for i := range propNames {`)
	wl(`		if primaryKeys[i] < 0 {`)
	wl(`			continue`)
	wl(`		}`)
	wl(`		values.Set(propKeys[primaryKeys[i]], config.propValue(configProp(i)))`)
	wl(`	}`)
	wl(`	return values`)
	wl(`}`)
	wl()

	return nil
}

func goType(ps *format.ConfigSpecProp) string {
	switch ps.Type {
	case format.TextPropType:
		return "string"
	case format.TogglePropType:
		return "bool"
	case format.NumberPropType:
		return "int64"
	case format.OptionPropType:
		return optionTypeName(ps.Name)
		// return "format.Option"
	case format.ListPropType:
		return "[]string"
	default:
		return "interface{}"
	}
}

func optionTypeName(name string) string {
	return strings.ToLower(name[:1]) + name[1:] + `Option`
}

func getUserInfoSetter(urlProps map[format.URLPart]string) string {
	var prop string
	var user_found bool
	var pass_found bool
	user := `""`
	if prop, user_found = urlProps[format.URLUser]; user_found {
		user = "config." + prop
	}
	pass := `""`
	if prop, pass_found = urlProps[format.URLPassword]; pass_found {
		pass = "config." + prop
	}

	if pass_found {
		return fmt.Sprintf(`		User: url.UserPassword(%v, %v),`, user, pass)
	} else if user_found {
		return fmt.Sprintf(`		User: url.User(%v),`, user)
	}

	return "		// Userinfo fields are not used for configuration"
}

func mapKeys[V any](m map[string]V) ([]string, int) {
	maxLen := 0
	keys := make([]string, 0, len(m))
	for name := range m {
		if len(name) > maxLen {
			maxLen = len(name)
		}
		keys = append(keys, name)
	}
	return keys, maxLen
}

func legacyTags(p *format.ConfigSpecProp) string {
	sb := strings.Builder{}
	sb.WriteRune('`')
	if len(p.Keys) > 0 {
		sb.WriteString(`key:"`)
		sb.WriteString(strings.Join(p.Keys, ","))
		sb.WriteString(`" `)
	}
	if len(p.URLParts) > 0 {
		sb.WriteString(`url:"`)
		for i, urlPart := range p.URLParts {
			if i > 0 {
				sb.WriteRune(',')
			}
			sb.WriteString(string(urlPart))
		}

		sb.WriteString(`" `)
	}
	sb.WriteRune('`')

	return sb.String()
}
