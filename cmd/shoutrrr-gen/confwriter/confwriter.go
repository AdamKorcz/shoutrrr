package confwriter

import (
	"fmt"
	"io"
	"sort"
	"strings"

	"github.com/apex/log"
	"github.com/containrrr/shoutrrr/internal/logging"
	"github.com/containrrr/shoutrrr/pkg/conf"
	"github.com/containrrr/shoutrrr/pkg/urlpart"
)

var logger = logging.GetLogger("ConfWriter")

type ConfWriter struct {
	spec *conf.Spec

	propNames       []string
	propNamesPadded []string
	keys            []string

	urlProps  map[urlpart.URLPart]string
	keyProps  map[string]int
	enumProps map[string][]string
}

var wl func(v ...interface{})
var wf func(format string, v ...interface{})

func New(spec *conf.Spec) *ConfWriter {

	logger.WithFields(log.Fields{
		"version": spec.Version,
		"scheme":  spec.Scheme,
	}).Debug("Verifying spec")

	propNames, maxPropNameLen := mapKeys(spec.Props)
	propNamePad := strings.Repeat(" ", maxPropNameLen)
	propNamesPadded := make([]string, len(propNames))

	urlProps := map[urlpart.URLPart]string{}
	keyProps := map[string]int{}
	enumProps := map[string][]string{}

	for i, p := range propNames {
		ps := spec.Props[p]
		spec.Props[p].Name = p
		for _, up := range ps.URLParts {
			urlProps[up] = p
		}
		for _, key := range ps.Keys {
			keyProps[key] = i
		}
		if len(ps.Values) > 0 {
			enumProps[p] = ps.Values
		}
		propNamesPadded[i] = p + propNamePad[:len(propNamePad)-len(p)]
	}

	keys := make([]string, 0, len(keyProps))
	for key := range keyProps {
		keys = append(keys, key)
	}
	sort.Strings(keys)

	logger.WithFields(log.Fields{
		"props": len(propNames),
		"keys":  len(keys),
		"enums": len(enumProps),
	}).Info("Spec loaded")

	return &ConfWriter{
		spec,
		propNames,
		propNamesPadded,
		keys,
		urlProps,
		keyProps,
		enumProps,
	}

}

func (cw *ConfWriter) WriteConfig(src io.Writer, args []string) error {
	wf = func(format string, v ...interface{}) {
		fmt.Fprintf(src, format+"\n", v...)
	}
	wl = func(v ...interface{}) {
		fmt.Fprintln(src, v...)
	}

	cw.writeHeader(args)
	if err := cw.writeProps(); err != nil {
		return err
	}
	cw.writeGetURL()
	if err := cw.writeSetURL(); err != nil {
		return err
	}
	cw.writeEnums()
	cw.writeUpdate()

	return nil
}

func (cw *ConfWriter) writeHeader(args []string) {

	logger.Debug("Writing header...")

	wf("// Code generated by \"shoutrrr-gen %s\"; DO NOT EDIT.", strings.Join(args[1:], " "))

	wl(`package`, cw.spec.Scheme)
	wl()
	wl(`import (`)
	wl(`	"fmt"`)
	wl(`	"net/url"`)
	wl()
	wl(`	"github.com/containrrr/shoutrrr/pkg/types"`)
	if len(cw.enumProps) > 0 {
		wl(`	"github.com/containrrr/shoutrrr/pkg/format"`)
	}
	wl(`	"github.com/containrrr/shoutrrr/pkg/conf"`)
	wl(`)`)
}

func (cw *ConfWriter) writeSection(section string) {
	logger.Debugf("Writing section %v...", section)
	wl()
	wl("// (‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾)")
	wf(`//  )  %-30v ( `, section)
	wl(`// (___________________________________)`)
	wl()
}

func (cw *ConfWriter) writeSubSection(name string) {
	logger.Debugf("Writing subsection %v...", name)
	wl()
	wf(`/* == %v %v */`, name, strings.Repeat("=", 40-len(name)))
	wl()
}

func legacyTags(p *conf.SpecProp) string {
	sb := strings.Builder{}
	sb.WriteRune('`')
	if len(p.Keys) > 0 {
		sb.WriteString(`key:"`)
		sb.WriteString(strings.Join(p.Keys, ","))
		sb.WriteString(`" `)
	}
	if len(p.URLParts) > 0 {
		sb.WriteString(`url:"`)
		for i, urlPart := range p.URLParts {
			if i > 0 {
				sb.WriteRune(',')
			}
			sb.WriteString(string(urlPart))
		}

		sb.WriteString(`" `)
	}
	sb.WriteRune('`')

	return sb.String()
}
