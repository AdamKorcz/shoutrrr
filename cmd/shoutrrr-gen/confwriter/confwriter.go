package confwriter

import (
	"fmt"
	"io"
	"sort"
	"strings"

	"github.com/apex/log"
	"github.com/containrrr/shoutrrr/internal/logging"
	"github.com/containrrr/shoutrrr/pkg/format"
)

var logger = logging.GetLogger("ConfWriter")

type ConfWriter struct {
	src  io.Writer
	spec *format.ConfigSpec

	propNames       []string
	propNamesPadded []string
	keys            []string

	urlProps  map[format.URLPart]string
	keyProps  map[string]string
	enumProps map[string][]string
}

var wl func(v ...interface{})
var wf func(format string, v ...interface{})

func New(spec *format.ConfigSpec, src io.Writer) *ConfWriter {

	wf = func(format string, v ...interface{}) {
		fmt.Fprintf(src, format+"\n", v...)
	}
	wl = func(v ...interface{}) {
		fmt.Fprintln(src, v...)
	}

	logger.Debug("Initializing from spec...")

	propNames, maxPropNameLen := mapKeys(spec.Props)
	sort.Strings(propNames)
	propNamePad := strings.Repeat(" ", maxPropNameLen)
	propNamesPadded := make([]string, len(propNames))

	urlProps := map[format.URLPart]string{}
	keyProps := map[string]string{}
	enumProps := map[string][]string{}

	for i, p := range propNames {
		ps := spec.Props[p]
		spec.Props[p].Name = p
		for _, up := range ps.URLParts {
			urlProps[up] = p
		}
		for _, key := range ps.Keys {
			keyProps[key] = p
		}
		if len(ps.Values) > 0 {
			enumProps[p] = ps.Values
		}
		propNamesPadded[i] = p + propNamePad[:len(propNamePad)-len(p)]
	}

	keys := make([]string, 0, len(keyProps))
	for key := range keyProps {
		keys = append(keys, key)
	}
	sort.Strings(keys)

	logger.WithFields(log.Fields{
		"Props": len(propNames),
		"Keys":  len(keys),
		"Enums": len(enumProps),
	}).Info("Spec loaded")

	return &ConfWriter{
		src,
		spec,
		propNames,
		propNamesPadded,
		keys,
		urlProps,
		keyProps,
		enumProps,
	}

}

func (cw *ConfWriter) WriteHeader(gopackage string, args []string) {

	logger.Debug("Writing header...")

	wf("// Code generated by \"shoutrrr-gen %s\"; DO NOT EDIT.", strings.Join(args[1:], " "))

	wl(`package`, gopackage)
	wl()
	wl(`import (`)
	wl(`	"fmt"`)
	wl(`	"net/url"`)
	wl(`	"strings"`)
	wl()
	wl(`	"github.com/containrrr/shoutrrr/pkg/types"`)
	wl(`	"github.com/containrrr/shoutrrr/pkg/format"`)
	wl(`)`)
}

func (cw *ConfWriter) writeSection(section string) {
	logger.Debugf("Writing section %v...", section)
	wl()
	wl("// (‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾)")
	wf(`//  )  %-30v ( `, section)
	wl(`// (___________________________________)`)
	wl()

	// wl(`  /*‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾/`)
	// wl(` /*`)
	// wf(` \  %-30v         `, section)
	// wl(`   ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\`)
	// wl(`                                         */`)
}

func (cw *ConfWriter) writeSubSection(name string) {
	logger.Debugf("Writing subsection %v...", name)
	wl()
	wf(`/* == %v %v */`, name, strings.Repeat("=", 40-len(name)))
	wl()
}

func goType(ps *format.ConfigSpecProp) string {
	switch ps.Type {
	case format.TextPropType:
		return "string"
	case format.TogglePropType:
		return "bool"
	case format.NumberPropType:
		return "int64"
	case format.OptionPropType:
		return optionTypeName(ps.Name)
		// return "format.Option"
	case format.ListPropType:
		return "[]string"
	case format.ColorPropType:
		return "uint32"
	case format.CustomPropType:
		return ps.Name + "Type"
	default:
		return "interface{}"
	}
}

func optionTypeName(name string) string {
	return strings.ToLower(name[:1]) + name[1:] + `Option`
}

func getPathSetter(urlProps map[format.URLPart]string) string {
	pathVal := `"/",`
	if prop, found := urlProps[format.URLPath]; found {
		pathVal = fmt.Sprintf(`string(config.%v),`, prop)
	} else {
		pathParts := []string{}
		for _, pp := range format.URLPathParts {
			if prop, found := urlProps[pp]; found {
				pathParts = append(pathParts, fmt.Sprintf(`string(config.%v)`, prop))
			} else {
				break
			}
		}
		if len(pathParts) > 0 {
			pathVal = fmt.Sprintf(`strings.Join([]string{%v}, "/"),`, strings.Join(pathParts, ", "))
		}
	}
	return `		Path: ` + pathVal
}

func writePathGetters(urlProps map[format.URLPart]string) {
	if prop, found := urlProps[format.URLPath]; found {
		wf(`	updates[%q] = url.Path`, prop)
		return
	} else {
		for i, pp := range format.URLPathParts {
			if prop, found := urlProps[pp]; found {
				if i == 0 {
					wl(`	pathParts := strings.Split(strings.TrimPrefix(url.Path, "/"), "/")`)
				}
				wf(`	updates[%q] = pathParts[%v]`, prop, i)
			} else {
				if i > 0 {
					wf(`	if len(pathParts) > %v {`, i)
					wf(`		return fmt.Errorf("too many path items: %%v, expected %v", len(pathParts))`, i)
					wl(`	}`)
				}
				break
			}
		}
	}
}

func getUserInfoSetter(urlProps map[format.URLPart]string) string {
	var prop string
	var user_found bool
	var pass_found bool
	user := `""`
	if prop, user_found = urlProps[format.URLUser]; user_found {
		user = "config." + prop
	}
	pass := `""`
	if prop, pass_found = urlProps[format.URLPassword]; pass_found {
		pass = "config." + prop
	}

	if pass_found {
		return fmt.Sprintf(`		User: url.UserPassword(%v, %v),`, user, pass)
	} else if user_found {
		return fmt.Sprintf(`		User: url.User(%v),`, user)
	}

	return "		// Userinfo fields are not used for configuration"
}

func mapKeys[V any](m map[string]V) ([]string, int) {
	maxLen := 0
	keys := make([]string, 0, len(m))
	for name := range m {
		if len(name) > maxLen {
			maxLen = len(name)
		}
		keys = append(keys, name)
	}
	return keys, maxLen
}

func legacyTags(p *format.ConfigSpecProp) string {
	sb := strings.Builder{}
	sb.WriteRune('`')
	if len(p.Keys) > 0 {
		sb.WriteString(`key:"`)
		sb.WriteString(strings.Join(p.Keys, ","))
		sb.WriteString(`" `)
	}
	if len(p.URLParts) > 0 {
		sb.WriteString(`url:"`)
		for i, urlPart := range p.URLParts {
			if i > 0 {
				sb.WriteRune(',')
			}
			sb.WriteString(string(urlPart))
		}

		sb.WriteString(`" `)
	}
	sb.WriteRune('`')

	return sb.String()
}
