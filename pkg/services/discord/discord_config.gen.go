// Code generated by "shoutrrr-gen --lang go ../../../spec/discord.yml"; DO NOT EDIT.
package discord

import (
	"fmt"
	"net/url"
	"strings"

	"github.com/containrrr/shoutrrr/pkg/types"
	"github.com/containrrr/shoutrrr/pkg/format"
)

// (‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾)
//  )  Props                          ( 
// (___________________________________)

type Config struct {
	Avatar     string `key:"avatar,avatarurl" `
	Color      uint32 `key:"color" `
	ColorDebug uint32 `key:"colordebug" `
	ColorError uint32 `key:"colorerror" `
	ColorInfo  uint32 `key:"colorinfo" `
	ColorWarn  uint32 `key:"colorwarn" `
	JSON       bool `key:"json" `
	RawMode    RawModeType `url:"path1" `
	SplitLines bool `key:"splitlines" `
	Title      string `key:"title" `
	Token      string `url:"user" `
	Username   string `key:"username" `
	WebhookID  string `url:"host" `
}

type configProp int
const (
	propAvatar     configProp = 0
	propColor      configProp = 1
	propColorDebug configProp = 2
	propColorError configProp = 3
	propColorInfo  configProp = 4
	propColorWarn  configProp = 5
	propJSON       configProp = 6
	propRawMode    configProp = 7
	propSplitLines configProp = 8
	propTitle      configProp = 9
	propToken      configProp = 10
	propUsername   configProp = 11
	propWebhookID  configProp = 12
	propCount = 13
)
var propNames = []string{
	"Avatar",
	"Color",
	"ColorDebug",
	"ColorError",
	"ColorInfo",
	"ColorWarn",
	"JSON",
	"RawMode",
	"SplitLines",
	"Title",
	"Token",
	"Username",
	"WebhookID",
}

// Note that propKeys may not align with propNames, as a property can have no or multiple keys
var propKeys = []string{
	"avatar",
	"avatarurl",
	"color",
	"colordebug",
	"colorerror",
	"colorinfo",
	"colorwarn",
	"json",
	"splitlines",
	"title",
	"username",
}

var keyProp = []configProp{
	propAvatar,
	propAvatar,
	propColor,
	propColorDebug,
	propColorError,
	propColorInfo,
	propColorWarn,
	propJSON,
	propSplitLines,
	propTitle,
	propUsername,
}

var defaultValues = []string{
	"",
	"#50D9ff",
	"#7b00ab",
	"#d60510",
	"#2488ff",
	"#ffc441",
	"No",
	"",
	"Yes",
	"",
	"",
	"",
	"",
}

var primaryKeys = []int{
	0,
	2,
	3,
	4,
	5,
	6,
	7,
	-1,
	8,
	9,
	-1,
	10,
	-1,
}


// (‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾)
//  )  GetURL                         ( 
// (___________________________________)

// GetURL returns a URL representation of it's current field values
func (config *Config) GetURL() *url.URL {
	return &url.URL{
		User: url.User(config.Token),
		Host: config.WebhookID,
		Path: strings.Join([]string{string(config.RawMode)}, "/"),
		RawQuery: config.QueryValues().Encode(),
		Scheme: Scheme,
	}
}


// (‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾)
//  )  SetURL                         ( 
// (___________________________________)

// SetURL updates a ServiceConfig from a URL representation of it's field values
func (config *Config) SetURL(url *url.URL) error {
	updates := make(map[string]string, propCount)
	updates["WebhookID"] = url.Host
	updates["Token"] = url.User.Username()
	pathParts := strings.Split(strings.TrimPrefix(url.Path, "/"), "/")
	updates["RawMode"] = pathParts[0]
	if len(pathParts) > 1 {
		return fmt.Errorf("too many path items: %v, expected 1", len(pathParts))
	}

	for key, value := range url.Query() {
		propName, err := propNameFromKey(key)
		if err == nil {
			updates[propName] = value[0]
		} else if key != "title" {
			return fmt.Errorf("invalid key %q", key)
		}
	}

	err := config.Update(updates); if err != nil {
		return err
	}

	if config.Token == "" {
		return fmt.Errorf("Token missing from config URL")
	}

	if config.WebhookID == "" {
		return fmt.Errorf("WebhookID missing from config URL")
	}

	return nil
}


// (‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾)
//  )  Enums / Options                ( 
// (___________________________________)

func (config *Config) Enums() map[string]types.EnumFormatter {
	return map[string]types.EnumFormatter{
	}
}

// Update updates the Config from a map of it's properties
func (config *Config) Update(updates map[string]string) error {
	var last_err error
	for key, value := range updates {
		switch key {
		case "Avatar":
			if val, err := format.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.Avatar = val
			}
		case "Color":
			if val, err := format.ParseColorValue(value); err != nil {
				last_err = err
			} else {
				config.Color = val
			}
		case "ColorDebug":
			if val, err := format.ParseColorValue(value); err != nil {
				last_err = err
			} else {
				config.ColorDebug = val
			}
		case "ColorError":
			if val, err := format.ParseColorValue(value); err != nil {
				last_err = err
			} else {
				config.ColorError = val
			}
		case "ColorInfo":
			if val, err := format.ParseColorValue(value); err != nil {
				last_err = err
			} else {
				config.ColorInfo = val
			}
		case "ColorWarn":
			if val, err := format.ParseColorValue(value); err != nil {
				last_err = err
			} else {
				config.ColorWarn = val
			}
		case "JSON":
			if val, err := format.ParseToggleValue(value); err != nil {
				last_err = err
			} else {
				config.JSON = val
			}
		case "RawMode":
			if val, err := config.setRawMode(value); err != nil {
				last_err = err
			} else {
				config.RawMode = val
			}
		case "SplitLines":
			if val, err := format.ParseToggleValue(value); err != nil {
				last_err = err
			} else {
				config.SplitLines = val
			}
		case "Title":
			if val, err := format.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.Title = val
			}
		case "Token":
			if val, err := format.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.Token = val
			}
		case "Username":
			if val, err := format.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.Username = val
			}
		case "WebhookID":
			if val, err := format.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.WebhookID = val
			}
		default:
			last_err = fmt.Errorf("invalid key")
		}
		if last_err != nil {
			return fmt.Errorf("failed to set value for %q: %v", key, last_err)
		}
	}
	return nil
}

// Update updates the Config from a map of it's properties
func (config *Config) propValue(prop configProp) string {
	switch prop {
	case propAvatar:
		return format.FormatTextValue(config.Avatar)
	case propColor:
		return format.FormatColorValue(config.Color)
	case propColorDebug:
		return format.FormatColorValue(config.ColorDebug)
	case propColorError:
		return format.FormatColorValue(config.ColorError)
	case propColorInfo:
		return format.FormatColorValue(config.ColorInfo)
	case propColorWarn:
		return format.FormatColorValue(config.ColorWarn)
	case propJSON:
		return format.FormatToggleValue(config.JSON)
	case propRawMode:
		return config.getRawMode()
	case propSplitLines:
		return format.FormatToggleValue(config.SplitLines)
	case propTitle:
		return format.FormatTextValue(config.Title)
	case propToken:
		return format.FormatTextValue(config.Token)
	case propUsername:
		return format.FormatTextValue(config.Username)
	case propWebhookID:
		return format.FormatTextValue(config.WebhookID)
	default:
		return ""
	}
}


// (‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾)
//  )  Helpers                        ( 
// (___________________________________)


func propNameFromKey(key string) (string, error) {
	key = strings.ToLower(key)
	for i, pk := range propKeys {
		if key == pk {
			return propNames[keyProp[i]], nil
		}
	}
	return "", fmt.Errorf("invalid key %q", key)
}

// UpdateFromParams updates the configuration from the supplied params
func (config *Config) UpdateFromParams(params *types.Params) error {
	if params == nil {
		return nil
	}
	updates := make(map[string]string, len(*params))
	for key, value := range *params {
		propName, err := propNameFromKey(key)
		if err == nil {
			updates[propName] = value
		} else if key != "title" {
			return fmt.Errorf("invalid key %q", key)
		}
	}
	return config.Update(updates)
}


// UpdateFromQuery updates the configuration from the supplied query values
func (config *Config) UpdateFromQuery(values url.Values) error {
	updates := make(map[string]string, len(values))
	for key, value := range values {
		propName, err := propNameFromKey(key)
		if err == nil {
			updates[propName] = value[0]
		} else if key != "title" {
			return fmt.Errorf("invalid key %q", key)
		}
	}
	return config.Update(updates)
}

// Init sets all the Config properties to their default values
func (config *Config) Init() error {
	updates := make(map[string]string, propCount)
	for i, name := range propNames {
		updates[name] = defaultValues[i]
	}
	return config.Update(updates)
}

// QueryValues returns a url.Values populated from the configuration
func (config *Config) QueryValues() url.Values {
	values := make(url.Values, propCount)
	for i := range propNames {
		if primaryKeys[i] < 0 {
			continue
		}
		value := config.propValue(configProp(i))
		if value == defaultValues[i] {
			continue
		}
		values.Set(propKeys[primaryKeys[i]], config.propValue(configProp(i)))
	}
	return values
}
	
