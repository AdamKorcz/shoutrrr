// Code generated by "shoutrrr-gen --lang go"; DO NOT EDIT.
package discord

import (
	"fmt"
	"net/url"

	"github.com/containrrr/shoutrrr/pkg/conf"
	"github.com/containrrr/shoutrrr/pkg/types"
)

// (‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾)
//  )  Props                          (
// (___________________________________)

type Config struct {
	Avatar     string      `key:"avatar,avatarurl" `
	Color      uint32      `key:"color" `
	ColorDebug uint32      `key:"colordebug" `
	ColorError uint32      `key:"colorerror" `
	ColorInfo  uint32      `key:"colorinfo" `
	ColorWarn  uint32      `key:"colorwarn" `
	JSON       bool        `key:"json" `
	RawMode    rawModeType `url:"path1" `
	SplitLines bool        `key:"splitlines" `
	Title      string      `key:"title" `
	Token      string      `url:"user" `
	Username   string      `key:"username" `
	WebhookID  string      `url:"host" `
}

type configProp int

const (
	propAvatar     configProp = 0
	propColor      configProp = 1
	propColorDebug configProp = 2
	propColorError configProp = 3
	propColorInfo  configProp = 4
	propColorWarn  configProp = 5
	propJSON       configProp = 6
	propRawMode    configProp = 7
	propSplitLines configProp = 8
	propTitle      configProp = 9
	propToken      configProp = 10
	propUsername   configProp = 11
	propWebhookID  configProp = 12
	propCount                 = 13
)

var propInfo = types.ConfigPropInfo{
	PropNames: []string{
		"Avatar",
		"Color",
		"ColorDebug",
		"ColorError",
		"ColorInfo",
		"ColorWarn",
		"JSON",
		"RawMode",
		"SplitLines",
		"Title",
		"Token",
		"Username",
		"WebhookID",
	},

	// Note that propKeys may not align with propNames, as a property can have no or multiple keys
	Keys: []string{
		"avatar",
		"avatarurl",
		"color",
		"colordebug",
		"colorerror",
		"colorinfo",
		"colorwarn",
		"json",
		"splitlines",
		"title",
		"username",
	},

	DefaultValues: []string{
		"",
		"#50D9ff",
		"#7b00ab",
		"#d60510",
		"#2488ff",
		"#ffc441",
		"No",
		"",
		"Yes",
		"",
		"",
		"",
		"",
	},

	PrimaryKeys: []int{
		0,
		2,
		3,
		4,
		5,
		6,
		7,
		-1,
		8,
		9,
		-1,
		10,
		-1,
	},

	KeyPropIndexes: map[string]int{
		"avatar":     0,
		"avatarurl":  0,
		"color":      1,
		"colordebug": 2,
		"colorerror": 3,
		"colorinfo":  4,
		"colorwarn":  5,
		"json":       6,
		"splitlines": 8,
		"title":      9,
		"username":   11,
	},
}

func (_ *Config) PropInfo() *types.ConfigPropInfo {
	return &propInfo
}

// (‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾)
//  )  GetURL                         (
// (___________________________________)

// GetURL returns a URL representation of it's current field values
func (config *Config) GetURL() *url.URL {
	return &url.URL{
		User:     conf.UserInfoOrNil(url.User(config.Token)),
		Host:     config.WebhookID,
		Path:     conf.JoinPath(string(config.RawMode)),
		RawQuery: conf.QueryValues(config).Encode(),
		Scheme:   Scheme,
	}
}

// (‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾)
//  )  SetURL                         (
// (___________________________________)

// SetURL updates a ServiceConfig from a URL representation of it's field values
func (config *Config) SetURL(configURL *url.URL) error {
	if lc, ok := (interface{})(config).(types.ConfigWithLegacyURLSupport); ok {
		configURL = lc.UpdateLegacyURL(configURL)
	}
	updates := make(map[int]string, propCount)
	updates[int(propWebhookID)] = configURL.Hostname()
	updates[int(propToken)] = configURL.User.Username()

	pathParts := conf.SplitPath(configURL.Path)
	if len(pathParts) > 0 {
		updates[int(propRawMode)] = pathParts[0]
	}
	if len(pathParts) > 1 {
		return fmt.Errorf("too many path items: %v, expected 1", len(pathParts))
	}

	for key, value := range configURL.Query() {

		if propIndex, found := propInfo.PropIndexFor(key); found {
			updates[propIndex] = value[0]
		} else if key != "title" {
			return fmt.Errorf("invalid key %q", key)
		}
	}

	err := config.Update(updates)
	if err != nil {
		return err
	}

	if config.Token == "" {
		return fmt.Errorf("token missing from config URL")
	}

	if config.WebhookID == "" {
		return fmt.Errorf("webhookID missing from config URL")
	}

	return nil
}

// (‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾)
//  )  Enums / Options                (
// (___________________________________)

func (config *Config) Enums() map[string]types.EnumFormatter {
	return map[string]types.EnumFormatter{}
}

// Update updates the Config from a map of it's properties
func (config *Config) Update(updates map[int]string) error {
	var last_err error
	for index, value := range updates {
		switch configProp(index) {
		case propAvatar:
			if val, err := conf.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.Avatar = val
			}
		case propColor:
			if val, err := conf.ParseColorValue(value); err != nil {
				last_err = err
			} else {
				config.Color = val
			}
		case propColorDebug:
			if val, err := conf.ParseColorValue(value); err != nil {
				last_err = err
			} else {
				config.ColorDebug = val
			}
		case propColorError:
			if val, err := conf.ParseColorValue(value); err != nil {
				last_err = err
			} else {
				config.ColorError = val
			}
		case propColorInfo:
			if val, err := conf.ParseColorValue(value); err != nil {
				last_err = err
			} else {
				config.ColorInfo = val
			}
		case propColorWarn:
			if val, err := conf.ParseColorValue(value); err != nil {
				last_err = err
			} else {
				config.ColorWarn = val
			}
		case propJSON:
			if val, err := conf.ParseToggleValue(value); err != nil {
				last_err = err
			} else {
				config.JSON = val
			}
		case propRawMode:
			if val, err := config.setRawMode(value); err != nil {
				last_err = err
			} else {
				config.RawMode = val
			}
		case propSplitLines:
			if val, err := conf.ParseToggleValue(value); err != nil {
				last_err = err
			} else {
				config.SplitLines = val
			}
		case propTitle:
			if val, err := conf.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.Title = val
			}
		case propToken:
			if val, err := conf.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.Token = val
			}
		case propUsername:
			if val, err := conf.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.Username = val
			}
		case propWebhookID:
			if val, err := conf.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.WebhookID = val
			}
		default:
			return fmt.Errorf("invalid key")
		}
		if last_err != nil {
			return fmt.Errorf("failed to set value for %v: %v", propInfo.PropNames[index], last_err)
		}
	}
	return nil
}

// Update updates the Config from a map of it's properties
func (config *Config) PropValue(prop int) string {
	switch configProp(prop) {
	case propAvatar:
		return conf.FormatTextValue(config.Avatar)
	case propColor:
		return conf.FormatColorValue(config.Color)
	case propColorDebug:
		return conf.FormatColorValue(config.ColorDebug)
	case propColorError:
		return conf.FormatColorValue(config.ColorError)
	case propColorInfo:
		return conf.FormatColorValue(config.ColorInfo)
	case propColorWarn:
		return conf.FormatColorValue(config.ColorWarn)
	case propJSON:
		return conf.FormatToggleValue(config.JSON)
	case propRawMode:
		return config.getRawMode()
	case propSplitLines:
		return conf.FormatToggleValue(config.SplitLines)
	case propTitle:
		return conf.FormatTextValue(config.Title)
	case propToken:
		return conf.FormatTextValue(config.Token)
	case propUsername:
		return conf.FormatTextValue(config.Username)
	case propWebhookID:
		return conf.FormatTextValue(config.WebhookID)
	default:
		return ""
	}
}
