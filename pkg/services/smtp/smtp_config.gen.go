// Code generated by "shoutrrr-gen --lang go ../../../spec/smtp.yml"; DO NOT EDIT.
package smtp

import (
	"fmt"
	"net/url"
	"strings"

	"github.com/containrrr/shoutrrr/pkg/types"
	"github.com/containrrr/shoutrrr/pkg/format"
)

// (‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾)
//  )  Props                          ( 
// (___________________________________)

type Config struct {
	Auth        authOption `key:"auth" `
	Encryption  encryptionOption `key:"encryption" `
	FromAddress string `key:"fromaddress,from" `
	FromName    string `key:"fromname" `
	Host        string `url:"host" `
	Password    string `url:"password" `
	Port        int64 `url:"port" `
	Subject     string `key:"subject,title" `
	ToAddresses []string `key:"toaddresses,to" `
	UseHTML     bool `key:"usehtml" `
	UseStartTLS bool `key:"starttls" `
	Username    string `url:"user" `
}

type configProp int
const (
	propAuth        configProp = 0
	propEncryption  configProp = 1
	propFromAddress configProp = 2
	propFromName    configProp = 3
	propHost        configProp = 4
	propPassword    configProp = 5
	propPort        configProp = 6
	propSubject     configProp = 7
	propToAddresses configProp = 8
	propUseHTML     configProp = 9
	propUseStartTLS configProp = 10
	propUsername    configProp = 11
	propCount = 12
)
var propNames = []string{
	"Auth",
	"Encryption",
	"FromAddress",
	"FromName",
	"Host",
	"Password",
	"Port",
	"Subject",
	"ToAddresses",
	"UseHTML",
	"UseStartTLS",
	"Username",
}

// Note that propKeys may not align with propNames, as a property can have no or multiple keys
var propKeys = []string{
	"auth",
	"encryption",
	"from",
	"fromaddress",
	"fromname",
	"starttls",
	"subject",
	"title",
	"to",
	"toaddresses",
	"usehtml",
}

var keyProp = []configProp{
	propAuth,
	propEncryption,
	propFromAddress,
	propFromAddress,
	propFromName,
	propUseStartTLS,
	propSubject,
	propSubject,
	propToAddresses,
	propToAddresses,
	propUseHTML,
}

var defaultValues = []string{
	"Unknown",
	"Auto",
	"",
	"",
	"",
	"",
	"25",
	"Shoutrrr Notification",
	"",
	"No",
	"Yes",
	"",
}

var primaryKeys = []int{
	0,
	1,
	3,
	4,
	-1,
	-1,
	-1,
	6,
	9,
	10,
	5,
	-1,
}


// (‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾)
//  )  GetURL                         ( 
// (___________________________________)

// GetURL returns a URL representation of it's current field values
func (config *Config) GetURL() *url.URL {
	return &url.URL{
		User: url.UserPassword(config.Username, config.Password),
		Host: config.Host,
		Path: "/",
		RawQuery: config.QueryValues().Encode(),
		Scheme: Scheme,
	}
}


// (‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾)
//  )  SetURL                         ( 
// (___________________________________)

// SetURL updates a ServiceConfig from a URL representation of it's field values
func (config *Config) SetURL(url *url.URL) error {
	updates := make(map[string]string, propCount)
	updates["Host"] = url.Host
	updates["Username"] = url.User.Username()
	if pwd, found := url.User.Password(); found {
		updates["Password"] = pwd
	}

	for key, value := range url.Query() {
		propName, err := propNameFromKey(key)
		if err == nil {
			updates[propName] = value[0]
		} else if key != "title" {
			return fmt.Errorf("invalid key %q", key)
		}
	}

	err := config.Update(updates); if err != nil {
		return err
	}

	if config.FromAddress == "" {
		return fmt.Errorf("FromAddress missing from config URL")
	}

	if config.Host == "" {
		return fmt.Errorf("Host missing from config URL")
	}

	if len(config.ToAddresses) == 0 {
		return fmt.Errorf("ToAddresses missing from config URL")
	}

	return nil
}


// (‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾)
//  )  Enums / Options                ( 
// (___________________________________)

func (config *Config) Enums() map[string]types.EnumFormatter {
	return map[string]types.EnumFormatter{
		"Encryption": EncryptionOptions.Formatter,
		"Auth": AuthOptions.Formatter,
	}
}


/* == Auth Option ============================= */

type authOption int

type authOptionVals struct {
	None	authOption
	Plain	authOption
	CRAMMD5	authOption
	Unknown	authOption
	OAuth2	authOption
	Formatter types.EnumFormatter
}

var AuthOptions = &authOptionVals {
	None:	0,
	Plain:	1,
	CRAMMD5:	2,
	Unknown:	3,
	OAuth2:	4,
	Formatter: format.CreateEnumFormatter([]string{
		"None",
		"Plain",
		"CRAMMD5",
		"Unknown",
		"OAuth2",
	}),
}

func (ov *authOptionVals) Parse(v string) (authOption, error) {
	if val := ov.Formatter.Parse(v); val != format.EnumInvalid {
		return authOption(val), nil
	} else {
		return authOption(val), fmt.Errorf("invalid option %q for Auth", v)
	}
}


/* == Encryption Option ======================= */

type encryptionOption int

type encryptionOptionVals struct {
	None	encryptionOption
	ExplicitTLS	encryptionOption
	ImplicitTLS	encryptionOption
	Auto	encryptionOption
	Formatter types.EnumFormatter
}

var EncryptionOptions = &encryptionOptionVals {
	None:	0,
	ExplicitTLS:	1,
	ImplicitTLS:	2,
	Auto:	3,
	Formatter: format.CreateEnumFormatter([]string{
		"None",
		"ExplicitTLS",
		"ImplicitTLS",
		"Auto",
	}),
}

func (ov *encryptionOptionVals) Parse(v string) (encryptionOption, error) {
	if val := ov.Formatter.Parse(v); val != format.EnumInvalid {
		return encryptionOption(val), nil
	} else {
		return encryptionOption(val), fmt.Errorf("invalid option %q for Encryption", v)
	}
}

// Update updates the Config from a map of it's properties
func (config *Config) Update(updates map[string]string) error {
	var last_err error
	for key, value := range updates {
		switch key {
		case "Auth":
			if val, err := AuthOptions.Parse(value); err != nil {
				last_err = err
			} else {
				config.Auth = val
			}
		case "Encryption":
			if val, err := EncryptionOptions.Parse(value); err != nil {
				last_err = err
			} else {
				config.Encryption = val
			}
		case "FromAddress":
			if val, err := format.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.FromAddress = val
			}
		case "FromName":
			if val, err := format.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.FromName = val
			}
		case "Host":
			if val, err := format.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.Host = val
			}
		case "Password":
			if val, err := format.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.Password = val
			}
		case "Port":
			if val, err := format.ParseNumberValue(value, 10); err != nil {
				last_err = err
			} else {
				config.Port = val
			}
		case "Subject":
			if val, err := format.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.Subject = val
			}
		case "ToAddresses":
			if val, err := format.ParseListValue(value); err != nil {
				last_err = err
			} else {
				config.ToAddresses = val
			}
		case "UseHTML":
			if val, err := format.ParseToggleValue(value); err != nil {
				last_err = err
			} else {
				config.UseHTML = val
			}
		case "UseStartTLS":
			if val, err := format.ParseToggleValue(value); err != nil {
				last_err = err
			} else {
				config.UseStartTLS = val
			}
		case "Username":
			if val, err := format.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.Username = val
			}
		default:
			last_err = fmt.Errorf("invalid key")
		}
		if last_err != nil {
			return fmt.Errorf("failed to set value for %q: %v", key, last_err)
		}
	}
	return nil
}

// Update updates the Config from a map of it's properties
func (config *Config) propValue(prop configProp) string {
	switch prop {
	case propAuth:
		return AuthOptions.Formatter.Print(int(config.Auth))
	case propEncryption:
		return EncryptionOptions.Formatter.Print(int(config.Encryption))
	case propFromAddress:
		return format.FormatTextValue(config.FromAddress)
	case propFromName:
		return format.FormatTextValue(config.FromName)
	case propHost:
		return format.FormatTextValue(config.Host)
	case propPassword:
		return format.FormatTextValue(config.Password)
	case propPort:
		return format.FormatNumberValue(config.Port, 10)
	case propSubject:
		return format.FormatTextValue(config.Subject)
	case propToAddresses:
		return format.FormatListValue(config.ToAddresses)
	case propUseHTML:
		return format.FormatToggleValue(config.UseHTML)
	case propUseStartTLS:
		return format.FormatToggleValue(config.UseStartTLS)
	case propUsername:
		return format.FormatTextValue(config.Username)
	default:
		return ""
	}
}


// (‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾)
//  )  Helpers                        ( 
// (___________________________________)


func propNameFromKey(key string) (string, error) {
	key = strings.ToLower(key)
	for i, pk := range propKeys {
		if key == pk {
			return propNames[keyProp[i]], nil
		}
	}
	return "", fmt.Errorf("invalid key %q", key)
}

// UpdateFromParams updates the configuration from the supplied params
func (config *Config) UpdateFromParams(params *types.Params) error {
	if params == nil {
		return nil
	}
	updates := make(map[string]string, len(*params))
	for key, value := range *params {
		propName, err := propNameFromKey(key)
		if err == nil {
			updates[propName] = value
		} else if key != "title" {
			return fmt.Errorf("invalid key %q", key)
		}
	}
	return config.Update(updates)
}


// UpdateFromQuery updates the configuration from the supplied query values
func (config *Config) UpdateFromQuery(values url.Values) error {
	updates := make(map[string]string, len(values))
	for key, value := range values {
		propName, err := propNameFromKey(key)
		if err == nil {
			updates[propName] = value[0]
		} else if key != "title" {
			return fmt.Errorf("invalid key %q", key)
		}
	}
	return config.Update(updates)
}

// Init sets all the Config properties to their default values
func (config *Config) Init() error {
	updates := make(map[string]string, propCount)
	for i, name := range propNames {
		updates[name] = defaultValues[i]
	}
	return config.Update(updates)
}

// QueryValues returns a url.Values populated from the configuration
func (config *Config) QueryValues() url.Values {
	values := make(url.Values, propCount)
	for i := range propNames {
		if primaryKeys[i] < 0 {
			continue
		}
		value := config.propValue(configProp(i))
		if value == defaultValues[i] {
			continue
		}
		values.Set(propKeys[primaryKeys[i]], config.propValue(configProp(i)))
	}
	return values
}
	
