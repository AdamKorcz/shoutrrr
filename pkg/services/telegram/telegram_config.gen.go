// Code generated by "shoutrrr-gen --lang go"; DO NOT EDIT.
package telegram

import (
	"fmt"
	"net/url"

	"github.com/containrrr/shoutrrr/pkg/conf"
	"github.com/containrrr/shoutrrr/pkg/format"
	"github.com/containrrr/shoutrrr/pkg/types"
)

// (‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾)
//  )  Props                          (
// (___________________________________)

type Config struct {
	APIHost      string          `url:"host" `
	BotID        string          `url:"user" `
	Chats        []string        `key:"chats,channels" `
	Notification bool            `key:"notification" `
	ParseMode    parseModeOption `key:"parsemode" `
	Preview      bool            `key:"preview" `
	Title        string          `key:"title" `
	Token        string          `url:"password" `
}

type configProp int

const (
	propAPIHost      configProp = 0
	propBotID        configProp = 1
	propChats        configProp = 2
	propNotification configProp = 3
	propParseMode    configProp = 4
	propPreview      configProp = 5
	propTitle        configProp = 6
	propToken        configProp = 7
	propCount                   = 8
)

var propInfo = types.ConfigPropInfo{
	PropNames: []string{
		"APIHost",
		"BotID",
		"Chats",
		"Notification",
		"ParseMode",
		"Preview",
		"Title",
		"Token",
	},

	// Note that propKeys may not align with propNames, as a property can have no or multiple keys
	Keys: []string{
		"channels",
		"chats",
		"notification",
		"parsemode",
		"preview",
		"title",
	},

	DefaultValues: []string{
		"telegram",
		"",
		"",
		"Yes",
		"None",
		"Yes",
		"",
		"",
	},

	PrimaryKeys: []int{
		-1,
		-1,
		1,
		2,
		3,
		4,
		5,
		-1,
	},

	KeyPropIndexes: map[string]int{
		"channels":     2,
		"chats":        2,
		"notification": 3,
		"parsemode":    4,
		"preview":      5,
		"title":        6,
	},
}

func (_ *Config) PropInfo() *types.ConfigPropInfo {
	return &propInfo
}

// (‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾)
//  )  GetURL                         (
// (___________________________________)

// GetURL returns a URL representation of it's current field values
func (config *Config) GetURL() *url.URL {
	return &url.URL{
		User:     conf.UserInfoOrNil(url.UserPassword(config.BotID, config.Token)),
		Host:     config.APIHost,
		Path:     "",
		RawQuery: conf.QueryValues(config).Encode(),
		Scheme:   Scheme,
	}
}

// (‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾)
//  )  SetURL                         (
// (___________________________________)

// SetURL updates a ServiceConfig from a URL representation of it's field values
func (config *Config) SetURL(configURL *url.URL) error {
	if lc, ok := (interface{})(config).(types.ConfigWithLegacyURLSupport); ok {
		configURL = lc.UpdateLegacyURL(configURL)
	}
	updates := make(map[int]string, propCount)
	updates[int(propAPIHost)] = configURL.Hostname()
	if pwd, found := configURL.User.Password(); found {
		updates[int(propToken)] = pwd
	}
	updates[int(propBotID)] = configURL.User.Username()
	if configURL.Path != "" && configURL.Path != "/" {
		return fmt.Errorf("unexpected path in config URL: %v", configURL.Path)
	}

	for key, value := range configURL.Query() {

		if propIndex, found := propInfo.PropIndexFor(key); found {
			updates[propIndex] = value[0]
		} else if key != "title" {
			return fmt.Errorf("invalid key %q", key)
		}
	}

	err := config.Update(updates)
	if err != nil {
		return err
	}

	if !conf.ValueMatchesPattern(config.BotID, "[0-9]+") {
		return fmt.Errorf("value %v for botID does not match the expected format", config.BotID)
	}

	if config.BotID == "" {
		return fmt.Errorf("botID missing from config URL")
	}

	if len(config.Chats) == 0 {
		return fmt.Errorf("chats missing from config URL")
	}

	if !conf.ValueMatchesPattern(config.Token, "[a-zA-Z0-9_-]+") {
		return fmt.Errorf("value %v for token does not match the expected format", config.Token)
	}

	if config.Token == "" {
		return fmt.Errorf("token missing from config URL")
	}

	return nil
}

// (‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾)
//  )  Enums / Options                (
// (___________________________________)

func (config *Config) Enums() map[string]types.EnumFormatter {
	return map[string]types.EnumFormatter{
		"ParseMode": ParseModeOptions.Formatter,
	}
}

/* == ParseMode Option ======================== */

type parseModeOption int

type parseModeOptionVals struct {
	None       parseModeOption
	Markdown   parseModeOption
	HTML       parseModeOption
	MarkdownV2 parseModeOption
	Formatter  types.EnumFormatter
}

var ParseModeOptions = &parseModeOptionVals{
	None:       0,
	Markdown:   1,
	HTML:       2,
	MarkdownV2: 3,
	Formatter: format.CreateEnumFormatter([]string{
		"None",
		"Markdown",
		"HTML",
		"MarkdownV2",
	}),
}

func (ov *parseModeOptionVals) Parse(v string) (parseModeOption, error) {
	if val := ov.Formatter.Parse(v); val != format.EnumInvalid {
		return parseModeOption(val), nil
	} else {
		return parseModeOption(val), fmt.Errorf("invalid option %q for ParseMode", v)
	}
}

func (o parseModeOption) String() string {
	return ParseModeOptions.Formatter.Print(int(o))
}

// Update updates the Config from a map of it's properties
func (config *Config) Update(updates map[int]string) error {
	var last_err error
	for index, value := range updates {
		switch configProp(index) {
		case propAPIHost:
			if val, err := conf.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.APIHost = val
			}
		case propBotID:
			if val, err := conf.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.BotID = val
			}
		case propChats:
			if val, err := conf.ParseListValue(value, ","); err != nil {
				last_err = err
			} else {
				config.Chats = val
			}
		case propNotification:
			if val, err := conf.ParseToggleValue(value); err != nil {
				last_err = err
			} else {
				config.Notification = val
			}
		case propParseMode:
			if val, err := ParseModeOptions.Parse(value); err != nil {
				last_err = err
			} else {
				config.ParseMode = val
			}
		case propPreview:
			if val, err := conf.ParseToggleValue(value); err != nil {
				last_err = err
			} else {
				config.Preview = val
			}
		case propTitle:
			if val, err := conf.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.Title = val
			}
		case propToken:
			if val, err := conf.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.Token = val
			}
		default:
			return fmt.Errorf("invalid key")
		}
		if last_err != nil {
			return fmt.Errorf("failed to set value for %v: %v", propInfo.PropNames[index], last_err)
		}
	}
	return nil
}

// Update updates the Config from a map of it's properties
func (config *Config) PropValue(prop int) string {
	switch configProp(prop) {
	case propAPIHost:
		return conf.FormatTextValue(config.APIHost)
	case propBotID:
		return conf.FormatTextValue(config.BotID)
	case propChats:
		return conf.FormatListValue(config.Chats, ",")
	case propNotification:
		return conf.FormatToggleValue(config.Notification)
	case propParseMode:
		return ParseModeOptions.Formatter.Print(int(config.ParseMode))
	case propPreview:
		return conf.FormatToggleValue(config.Preview)
	case propTitle:
		return conf.FormatTextValue(config.Title)
	case propToken:
		return conf.FormatTextValue(config.Token)
	default:
		return ""
	}
}
