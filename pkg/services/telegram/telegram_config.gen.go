// Code generated by "shoutrrr-gen pkg/services/telegram/config-spec.yml"; DO NOT EDIT.
package telegram

import (
	"fmt"
	"net/url"
	"strings"

	"github.com/containrrr/shoutrrr/pkg/types"
	"github.com/containrrr/shoutrrr/pkg/format"
)

type Config struct {
	Chats []string
	Notification bool
	ParseMode format.Option
	Preview bool
	Title string
	Token string
}

type ConfigProp int
const (
	ChatsProp	ConfigProp = 0
	NotificationProp	ConfigProp = 1
	ParseModeProp	ConfigProp = 2
	PreviewProp	ConfigProp = 3
	TitleProp	ConfigProp = 4
	TokenProp	ConfigProp = 5
	PropCount = 6
)
var propNames = []string{
	"Chats",
	"Notification",
	"ParseMode",
	"Preview",
	"Title",
	"Token",
}

var propKeys = []string{
	"channels",
	"chats",
	"notification",
	"parsemode",
	"preview",
	"title",
}

var defaultValues = []string{
	"",
	"Yes",
	"None",
	"Yes",
	"",
	"",
}

// GetURL returns a URL representation of it's current field values
func (config *Config) GetURL() *url.URL {
	return &url.URL{
		User: url.User(config.Token),
	}
}

// SetURL updates a ServiceConfig from a URL representation of it's field values
func (config *Config) SetURL(url *url.URL) error {
	config.Token = url.User.Username()

	if qv := url.Query()["channels"]; len(qv) == 1 {
		config.Chats = strings.Split(qv[0], ",")
	}
	if qv := url.Query()["chats"]; len(qv) == 1 {
		config.Chats = strings.Split(qv[0], ",")
	}
	if qv := url.Query()["notification"]; len(qv) == 1 {
		if v, ok := format.ParseBool(qv[0], false); ok {
			config.Notification = v
		}
	}
	if qv := url.Query()["parsemode"]; len(qv) == 1 {
		if v := ParseModeFormatter.Parse(qv[0]); v != format.EnumInvalid {
			config.ParseMode = format.Option(v)
		} else {
			return fmt.Errorf("Error parsing value for ParseMode: %q is not a valid option", qv[0])
		}
	}
	if qv := url.Query()["preview"]; len(qv) == 1 {
		if v, ok := format.ParseBool(qv[0], false); ok {
			config.Preview = v
		}
	}
	if qv := url.Query()["title"]; len(qv) == 1 {
		config.Title = qv[0]
	}

	return nil
}

func (config *Config) Enums() map[string]types.EnumFormatter {
	return map[string]types.EnumFormatter{
		"ParseMode": ParseModeFormatter,
	}
}

var (
	ParseModeFormatter = format.CreateEnumFormatter([]string{
		"None",
		"Markdown",
		"HTML",
		"MarkdownV2",
	})
)
// Update updates the Config from a map of it's properties
func (config *Config) Update(updates map[string]string) error {
	var last_err error
	for key, value := range updates {
		switch key {
		case "Chats":
			if val, err := format.ParseListValue(value); err != nil {
				last_err = err
			} else {
				config.Chats = val
			}
		case "Notification":
			if val, err := format.ParseToggleValue(value); err != nil {
				last_err = err
			} else {
				config.Notification = val
			}
		case "ParseMode":
			if val, err := format.ParseOptionValue(value, ParseModeFormatter); err != nil {
				last_err = err
			} else {
				config.ParseMode = val
			}
		case "Preview":
			if val, err := format.ParseToggleValue(value); err != nil {
				last_err = err
			} else {
				config.Preview = val
			}
		case "Title":
			if val, err := format.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.Title = val
			}
		case "Token":
			if val, err := format.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.Token = val
			}
		default:
			last_err = fmt.Errorf("invalid key")
		}
		if last_err != nil {
			return fmt.Errorf("failed to set value for %q: %v", key, last_err)
		}
	}
	return nil
}

// Init sets all the Config properties to their default values
func (config *Config) Init() {
	updates := make(map[string]string, len(propNames))
	for i, name := range propNames {
		updates[name] = defaultValues[i]
	}
	config.Update(updates)
}

