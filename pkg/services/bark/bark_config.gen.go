// Code generated by "shoutrrr-gen --lang go ../../../spec/bark.yml"; DO NOT EDIT.
package bark

import (
	"fmt"
	"net/url"

	"github.com/containrrr/shoutrrr/pkg/types"
	"github.com/containrrr/shoutrrr/pkg/format"
)

type Config struct {
	Badge     int64
	Category  string
	Copy      string
	DeviceKey string
	Group     string
	Host      string
	Icon      string
	Path      string
	Scheme    string
	Sound     string
	Title     string
	URL       string
}

type configProp int
const (
	propBadge     configProp = 0
	propCategory  configProp = 1
	propCopy      configProp = 2
	propDeviceKey configProp = 3
	propGroup     configProp = 4
	propHost      configProp = 5
	propIcon      configProp = 6
	propPath      configProp = 7
	propScheme    configProp = 8
	propSound     configProp = 9
	propTitle     configProp = 10
	propURL       configProp = 11
	propCount = 12
)
var propNames = []string{
	"Badge",
	"Category",
	"Copy",
	"DeviceKey",
	"Group",
	"Host",
	"Icon",
	"Path",
	"Scheme",
	"Sound",
	"Title",
	"URL",
}

// Note that propKeys may not align with propNames, as a property can have no or multiple keys
var propKeys = []string{
	"badge",
	"category",
	"copy",
	"group",
	"icon",
	"scheme",
	"sound",
	"title",
	"url",
}

var defaultValues = []string{
	"0",
	"",
	"",
	"",
	"",
	"",
	"",
	"/",
	"https",
	"",
	"",
	"",
}

// GetURL returns a URL representation of it's current field values
func (config *Config) GetURL() *url.URL {
	return &url.URL{
		User: url.UserPassword("", config.DeviceKey),
		Host: config.Host,
	}
}

// SetURL updates a ServiceConfig from a URL representation of it's field values
func (config *Config) SetURL(url *url.URL) error {
	updates := make(map[string]string, propCount)
	updates["Host"] = url.Host
	if pwd, found := url.User.Password(); found {
		updates["DeviceKey"] = pwd
	}

	if qv := url.Query()["badge"]; len(qv) == 1 {
        updates["Badge"] = qv[0]
	}
	if qv := url.Query()["category"]; len(qv) == 1 {
        updates["Category"] = qv[0]
	}
	if qv := url.Query()["copy"]; len(qv) == 1 {
        updates["Copy"] = qv[0]
	}
	if qv := url.Query()["group"]; len(qv) == 1 {
        updates["Group"] = qv[0]
	}
	if qv := url.Query()["icon"]; len(qv) == 1 {
        updates["Icon"] = qv[0]
	}
	if qv := url.Query()["scheme"]; len(qv) == 1 {
        updates["Scheme"] = qv[0]
	}
	if qv := url.Query()["sound"]; len(qv) == 1 {
        updates["Sound"] = qv[0]
	}
	if qv := url.Query()["title"]; len(qv) == 1 {
        updates["Title"] = qv[0]
	}
	if qv := url.Query()["url"]; len(qv) == 1 {
        updates["URL"] = qv[0]
	}

	return nil
}

func (config *Config) Enums() map[string]types.EnumFormatter {
	return map[string]types.EnumFormatter{
	}
}

var (
)
// Update updates the Config from a map of it's properties
func (config *Config) Update(updates map[string]string) error {
	var last_err error
	for key, value := range updates {
		switch key {
		case "Badge":
			if val, err := format.ParseNumberValue(value, 10); err != nil {
				last_err = err
			} else {
				config.Badge = val
			}
		case "Category":
			if val, err := format.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.Category = val
			}
		case "Copy":
			if val, err := format.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.Copy = val
			}
		case "DeviceKey":
			if val, err := format.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.DeviceKey = val
			}
		case "Group":
			if val, err := format.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.Group = val
			}
		case "Host":
			if val, err := format.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.Host = val
			}
		case "Icon":
			if val, err := format.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.Icon = val
			}
		case "Path":
			if val, err := format.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.Path = val
			}
		case "Scheme":
			if val, err := format.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.Scheme = val
			}
		case "Sound":
			if val, err := format.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.Sound = val
			}
		case "Title":
			if val, err := format.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.Title = val
			}
		case "URL":
			if val, err := format.ParseTextValue(value); err != nil {
				last_err = err
			} else {
				config.URL = val
			}
		default:
			last_err = fmt.Errorf("invalid key")
		}
		if last_err != nil {
			return fmt.Errorf("failed to set value for %q: %v", key, last_err)
		}
	}
	return nil
}

// Init sets all the Config properties to their default values
func (config *Config) Init() {
	updates := make(map[string]string, propCount)
	for i, name := range propNames {
		updates[name] = defaultValues[i]
	}
	config.Update(updates)
}

